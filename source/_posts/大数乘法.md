---
title: 大数乘法
typora-root-url: ../../source
date: 2018-06-12 18:27:11
categories: cpp
---
coursera北大的c++课上的一道题，本地ok，poj(pku的OJ)上ok，垃圾coursera上compile error。
先贴在这里，我感觉写的还是很优雅的。

```
#include <iostream>  
#include <algorithm>
#include <string>
using namespace std;

class BigInt {
public:
	BigInt(){
		values = "0";
		flag = true;
	}
	BigInt(const string stringvalue){
		values = stringvalue;
		flag = true;
	}
	BigInt(const int intvalue){
		if (intvalue >= 0){
			values = to_string(intvalue);
			flag = true;
		}
		else{
			values = to_string(-intvalue);
			flag = false;
		}
	}
	//~BigInt();
	friend ostream& operator << (ostream& out, const BigInt& b);
	friend istream& operator >> (istream& in, const BigInt& b);
	BigInt& operator + (BigInt b);
	BigInt& operator - (BigInt b);
	BigInt& operator * (BigInt b);
	BigInt& operator / (BigInt b);
	bool operator >= (BigInt b);

//private:
	string values;
	bool flag;
};

bool BigInt::operator >= (BigInt b){
	int agb = 0;
	if (values.length() > b.values.length())
	{
		agb = 1;
	}
	else if (values.length() < b.values.length())
	{
		agb = -1;
	}
	else
	{
		agb = values.compare(b.values);
	}
	return agb>=0;
}

 BigInt& BigInt :: operator + (BigInt b) {

	if (flag == b.flag){
		string res = "";
		reverse(values.begin(), values.end());
		reverse(b.values.begin(), b.values.end());
		int i = 0, carry = 0;
		for (; i < values.length() && i < b.values.length(); ++i){
			int tmp = values[i] - '0' + b.values[i] - '0' + carry;
			carry = tmp / 10;
			tmp = tmp % 10;
			res = (char)(tmp + '0') + res;
		}
		if (i < values.length()){
			for (; i < values.length(); ++i){
				int tmp = values[i] - '0' + carry;
				carry = tmp / 10;
				tmp = tmp % 10;
				res = (char)(tmp + '0') + res;
			}
		}
		else if (i < b.values.length()){
			for (; i < b.values.length(); ++i){
				int tmp = b.values[i] - '0' + carry;
				carry = tmp / 10;
				tmp = tmp % 10;
				res = (char)(tmp + '0') + res;
			}
		}
		if (carry == 1)
			res = '1' + res;
		values = res;
	}
	else{
		int agb = 0;
		if (values.length() > b.values.length())
		{
			agb = 1;
		}
		else if (values.length() < b.values.length())
		{
			agb = -1;
		}
		else
		{
			agb = values.compare(b.values);
		}
		if (0 == agb)
		{
			values = "0";
			return *this;
		}
		
		else if (agb < 0){
			flag = !flag;
			string tmp = values;
			values = b.values;
			b.values = tmp;
		}
		string res = "";
		reverse(values.begin(), values.end());
		reverse(b.values.begin(), b.values.end());
		int i = 0;
		for (; i < values.length() && i < b.values.length(); ++i)
			res.push_back(values.at(i) - b.values.at(i) + '0');

		if (i < values.length()) 
			for (; i < values.length(); ++i)
				res.push_back(values.at(i));

		int carry = 0;
		for (i = 0; i < values.length(); ++i)
		{
			int newValue = res.at(i) - carry - '0';
			if (newValue < 0) carry = 1;
			else carry = 0;
			res.at(i) = newValue + carry * 10 + '0';
		}
		while (res[res.length() - 1] == '0')
			res.pop_back();
		reverse(res.begin(), res.end());
		values = res;
	}

	return *this;
}

 BigInt &BigInt::operator - (BigInt b)
 {	
	 BigInt tmp(b);
	 tmp.flag = !tmp.flag;
	 return *this+tmp;
 }

 BigInt &BigInt::operator * (BigInt b)
 {
	 BigInt res;
	 if (values == "0" || b.values == "0"){
		 values = "0";
		 return *this;
	 }
	 if (flag == b.flag)
		 flag = true;
	 else
		 flag = false;

	 BigInt thisbk(*this);
	 for (int i = 0; i < b.values.length(); ++i){
		 for (int j = 0; j < b.values[i] - '0'; ++j){
			 res = res + thisbk;
		 }
		res.values.push_back('0');
	 }
	 res.values.pop_back();
	 values = res.values;
	 return *this;
 }

 BigInt &BigInt::operator / (BigInt b)
 {
	 if (b.values == "0")
		 throw "Division by zero condition!";
	 if (flag == b.flag)
		 flag = true;
	 else
		 flag = false;

	 BigInt one(1);
	 while (*this >= b){
		 b.values.push_back('0');
		 one.values.push_back('0');
	 }
	 b.values.pop_back();
	 one.values.pop_back();

	 BigInt thisbk(*this), res(0);
	 while (one.values.compare("0") > 0){
		 while (*this >= b){
			 *this - b;
			 res + one;
		 }
		 b.values.pop_back();
		 one.values.pop_back();
	 }
	 values = res.values;
	 return *this;
 }

ostream& operator << (ostream& ou, const BigInt& b)
{
	if (!b.flag)
		ou << '-';
	ou << b.values;
	return ou;
}

istream& operator >> (istream& in, BigInt& b)
{
	string str;
	in >> str;
	b.values = str;
	return in;
}

int main()
{
	BigInt b1, b2;
	string str;
	cin >> b1 >> str >> b2;

	if (str == "+")
	{
		cout << b1 + b2 << endl;
	}
	else if (str == "-")
	{
		cout << b1 - b2 << endl;
	}
	else if (str == "*")
	{
		cout << b1 * b2 << endl;
	}
	else
	{
		cout << b1 / b2 << endl;
	}
	return 0;
}
```
